/// <reference types="node" />
import { ExecuteDelayed, ExecuteNextTick, ExecutePeriodically, IncomingListenMessage, ListenOptions, ListenSubscribeOptions, MqttClientConstructorOptions, MqttSubscription, RegisterClientOptions, Resolvable, StopExecuting, TimerRef } from './mqtt.types';
import { PacketFlowData, PacketFlowFunc } from './flow';
import { MqttParseResult, MqttTransformer } from './mqtt.parser';
import { Transport } from './transport';
import { ConnectRequestOptions, SubscribeReturnCode } from './packets';
import { MqttMessageOutgoing } from './mqtt.message';
import { Writable } from 'stream';
import { DefaultPacketReadResultMap, PacketReadResultMap, DefaultPacketWriteOptions, PacketWriteOptionsMap, PacketWriter } from './packets';
import { PacketType } from './mqtt.constants';
import { MqttBaseClient } from './mqtt.base-client';
import { HandlerFn, MqttListener, RemoveHandlerFn } from './mqtt.listener';
export declare class MqttClient<ReadMap extends PacketReadResultMap = DefaultPacketReadResultMap, WriteMap extends PacketWriteOptionsMap = DefaultPacketWriteOptions> extends MqttBaseClient<ReadMap, WriteMap> {
    private mqttDebug;
    private receiveDebug;
    private pingDebug;
    protected executeNextTick: ExecuteNextTick;
    protected executePeriodically: ExecutePeriodically;
    protected stopExecuting: StopExecuting;
    protected executeDelayed: ExecuteDelayed;
    get keepAlive(): number;
    set keepAlive(value: number);
    protected transport: Transport<unknown>;
    protected transformer: MqttTransformer<ReadMap>;
    protected createTransformer: () => MqttTransformer<ReadMap>;
    protected pipeline?: Writable;
    protected writer: PacketWriter<WriteMap>;
    protected connectTimer?: TimerRef;
    protected keepAliveTimer?: TimerRef;
    protected autoReconnect: boolean;
    protected activeFlows: PacketFlowData<any>[];
    protected messageListener: MqttListener;
    constructor(options: MqttClientConstructorOptions<ReadMap, WriteMap>);
    connect(options?: Resolvable<RegisterClientOptions>): Promise<any>;
    protected registerClient(options: RegisterClientOptions, noNewPromise?: boolean, lastFlow?: PacketFlowFunc<ReadMap, WriteMap, unknown>): Promise<any>;
    protected getConnectFlow(options: ConnectRequestOptions): PacketFlowFunc<ReadMap, WriteMap, unknown>;
    publish(message: MqttMessageOutgoing): Promise<MqttMessageOutgoing>;
    subscribe(subscription: MqttSubscription): Promise<SubscribeReturnCode>;
    unsubscribe(subscription: MqttSubscription): Promise<void>;
    disconnect(force?: boolean): Promise<void>;
    listenSubscribe<T = IncomingListenMessage>(topic: string, handlerFn: HandlerFn<T>): Promise<RemoveHandlerFn>;
    listenSubscribe<T = IncomingListenMessage, Params extends Record<string, string> = Record<string, string>>(options: ListenSubscribeOptions<T, Params>, handlerFn: HandlerFn<T>): Promise<RemoveHandlerFn>;
    listen<T>(topic: string, handlerFn: HandlerFn<T>): RemoveHandlerFn;
    listen<T, Params extends Record<string, string>>(options: ListenOptions<T, Params>, handlerFn: HandlerFn<T>): RemoveHandlerFn;
    startFlow<T>(flow: PacketFlowFunc<ReadMap, WriteMap, T>): Promise<T>;
    /**
     *  Run the accept and next function of all active flows
     * @param {MqttPacket} packet
     * @returns {boolean} true if a flow has been found
     */
    protected continueFlows(packet: MqttParseResult<ReadMap, typeof PacketType[keyof typeof PacketType]>): boolean;
    protected clearFinishedFlows(): void;
    protected updateKeepAlive(value: number): void;
    protected sendData(data: Buffer): void;
    protected handlePacket(packet: MqttParseResult<ReadMap, PacketType>): Promise<void>;
    protected logReceivedPacket(packet: {
        type: PacketType;
        data: any;
    }): void;
    protected reset(): void;
    protected setReady(): void;
    protected setDisconnected(reason?: string): Promise<void>;
}
