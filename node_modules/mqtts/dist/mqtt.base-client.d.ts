import { RegisterClientOptions, Resolvable } from './mqtt.types';
import EventEmitter = require('eventemitter3');
import { PacketReadResultMap } from './packets/packet-reader';
import { PacketWriteOptionsMap } from './packets/packet-writer';
import { MqttMessage } from './mqtt.message';
import { EventMapping, PacketType } from './mqtt.constants';
export declare enum StateId {
    Fatal = -1,
    Created = 0,
    Connecting = 1,
    Ready = 2,
    Disconnected = 3
}
export declare class MqttBaseClient<ReadMap extends PacketReadResultMap, WriteMap extends PacketWriteOptionsMap> extends EventEmitter<{
    error: (e: Error) => void;
    warning: (e: Error) => void;
    connect: (packet: ReadMap[PacketType.ConnAck]) => void;
    disconnect: (reason?: string) => void;
    message: (message: MqttMessage) => void;
} & {
    [x in keyof EventMapping]: (arg: ReadMap[EventMapping[x]]) => void;
}> {
    private sate;
    get current(): StateId;
    get created(): boolean;
    get fatal(): boolean;
    get ready(): boolean;
    get connecting(): boolean;
    get disconnected(): boolean;
    protected emitWarning: (e: Error) => boolean;
    protected emitError: (e: Error) => boolean;
    protected emitDisconnect: (reason?: string | undefined) => boolean;
    protected emitConnect: (packet: ReadMap[PacketType.ConnAck]) => boolean;
    protected emitMessage: (message: MqttMessage) => boolean;
    constructor(sate?: StateId);
    private next;
    expectReady(): void;
    expectCreated(): void;
    expectConnecting(): void;
    protected reset(): void;
    protected setConnecting(): void;
    protected setReady(): void;
    protected setDisconnected(): void;
    protected setFatal(): void;
    private _connectResolver?;
    private _connectOptions?;
    set connectOptions(options: RegisterClientOptions | undefined);
    get connectOptions(): RegisterClientOptions | undefined;
    set connectResolver(resolver: Resolvable<RegisterClientOptions> | undefined);
    hasConnectOptions(): boolean;
    resolveConnectOptions(): Promise<RegisterClientOptions>;
    private _connectPromise?;
    private _connectResolve?;
    private _connectReject?;
    createConnectPromise(): Promise<void>;
    resolveConnectPromise(): void;
    rejectConnectPromise(e: Error): void;
}
