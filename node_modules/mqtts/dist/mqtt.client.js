"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MqttClient = void 0;
const flow_1 = require("./flow");
const mqtt_parser_1 = require("./mqtt.parser");
const transport_1 = require("./transport");
const errors_1 = require("./errors");
const stream_1 = require("stream");
const packets_1 = require("./packets");
const mqtt_constants_1 = require("./mqtt.constants");
const debug = require("debug");
const mqtt_base_client_1 = require("./mqtt.base-client");
const mqtt_listener_1 = require("./mqtt.listener");
const mqtt_utilities_1 = require("./mqtt.utilities");
class MqttClient extends mqtt_base_client_1.MqttBaseClient {
    constructor(options) {
        var _a, _b, _c, _d;
        super();
        this.mqttDebug = debug('mqtt:client');
        this.receiveDebug = this.mqttDebug.extend('packet');
        this.pingDebug = this.mqttDebug.extend('ping');
        // wrapper functions
        this.executeNextTick = process.nextTick;
        this.executePeriodically = (ms, cb) => setInterval(cb, ms);
        this.stopExecuting = clearInterval;
        this.executeDelayed = (ms, cb) => setTimeout(cb, ms);
        this.activeFlows = [];
        this.messageListener = new mqtt_listener_1.MqttListener();
        this.autoReconnect = !!options.autoReconnect;
        this.transport = (_a = options.transport) !== null && _a !== void 0 ? _a : new transport_1.TlsTransport({
            host: options.host,
            port: options.port,
            additionalOptions: {
                enableTrace: options.enableTrace,
            },
        });
        this.createTransformer = (_b = options.createTransformer) !== null && _b !== void 0 ? _b : (() => {
            var _a;
            return new mqtt_parser_1.MqttTransformer({
                debug: this.mqttDebug.extend('transformer'),
                mapping: (_a = options.readMap) !== null && _a !== void 0 ? _a : packets_1.DefaultPacketReadMap,
            });
        });
        this.transformer = this.createTransformer();
        this.transformer.options.debug = (_c = this.transformer.options.debug) !== null && _c !== void 0 ? _c : this.mqttDebug.extend('transformer');
        const packetLogger = this.mqttDebug.extend('write');
        this.writer = (_d = options.packetWriter) !== null && _d !== void 0 ? _d : new packets_1.PacketWriter({
            logPacketWrite: mqtt_utilities_1.createDefaultPacketLogger(packetLogger),
        }, options.writeMap);
    }
    get keepAlive() {
        var _a, _b;
        return (_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.keepAlive) !== null && _b !== void 0 ? _b : 0;
    }
    set keepAlive(value) {
        if (this.connectOptions) {
            this.connectOptions.keepAlive = value;
            if (value) {
                this.updateKeepAlive(value);
            }
        }
    }
    async connect(options) {
        this.expectCreated();
        this.mqttDebug('Connecting...');
        this.connectResolver = options;
        this.setConnecting();
        this.pipeline = stream_1.pipeline(this.transport.duplex, this.transformer, new stream_1.Writable({
            write: (chunk, encoding, callback) => {
                if (!chunk.type) {
                    callback(new Error('Chunk is not a MqttPacket'));
                    return;
                }
                this.handlePacket(chunk)
                    .then(() => callback())
                    .catch(callback);
            },
            objectMode: true,
        }), err => {
            if (err)
                this.emitError(err);
            if (!this.disconnected)
                this.setDisconnected('Pipeline finished');
        });
        await this.transport.connect();
        return this.registerClient(await this.resolveConnectOptions());
    }
    registerClient(options, noNewPromise = false, lastFlow) {
        var _a;
        let promise;
        if (noNewPromise) {
            const flow = this.activeFlows.find(x => x.flowId === lastFlow);
            if (!flow) {
                promise = Promise.reject(new Error('Could not find flow'));
            }
            else {
                const packet = flow.callbacks.start();
                if (packet)
                    this.sendData(this.writer.write(packet.type, packet.options));
                promise = Promise.resolve();
            }
        }
        else {
            promise = this.createConnectPromise();
            lastFlow = lastFlow !== null && lastFlow !== void 0 ? lastFlow : this.getConnectFlow(options);
            this.startFlow(lastFlow)
                .then(() => this.resolveConnectPromise())
                .catch(e => this.rejectConnectPromise(e));
        }
        this.connectTimer =
            typeof options.connectDelay === 'undefined'
                ? undefined
                : this.executeDelayed((_a = options.connectDelay) !== null && _a !== void 0 ? _a : 2000, () => 
                // This Promise will only reject if the flow wasn't found
                this.registerClient(options, true, lastFlow).catch(e => this.rejectConnectPromise(e)));
        return promise;
    }
    getConnectFlow(options) {
        // assume the defaults are used
        return flow_1.outgoingConnectFlow(options);
    }
    publish(message) {
        return this.startFlow(flow_1.outgoingPublishFlow(message));
    }
    subscribe(subscription) {
        return this.startFlow(flow_1.outgoingSubscribeFlow(subscription));
    }
    unsubscribe(subscription) {
        return this.startFlow(flow_1.outgoingUnsubscribeFlow(subscription));
    }
    async disconnect(force = false) {
        this.autoReconnect = false;
        if (!force) {
            return this.startFlow(flow_1.outgoingDisconnectFlow()).then(async () => await this.setDisconnected());
        }
        else {
            await this.setDisconnected('Forced Disconnect');
        }
    }
    listenSubscribe(options, handlerFn) {
        const listener = typeof options === 'string' ? { topic: options } : options;
        return this.subscribe({
            ...listener.subscriptionInfo,
            topic: listener.topic.replace(/\/:[A-Za-z-_0-9]+/g, '/+'),
        }).then(() => this.listen(listener, handlerFn));
    }
    listen(options, handlerFn) {
        const listener = typeof options === 'string' ? { topic: options } : options;
        const [topicFilter, paramMatcher] = mqtt_utilities_1.toMqttTopicFilter(listener.topic);
        return this.messageListener.addHandler({
            topicFilter,
            handle: handlerFn,
            transformer: listener.transformer,
            validator: listener.validator,
            paramMatcher,
        });
    }
    startFlow(flow) {
        return new Promise((resolve, reject) => {
            const data = {
                resolvers: { resolve, reject },
                finished: false,
                callbacks: flow(value => {
                    data.finished = true;
                    resolve(value);
                }, err => {
                    data.finished = true;
                    reject(err);
                }),
                flowId: flow,
            };
            const first = data.callbacks.start();
            if (first)
                this.sendData(this.writer.write(first.type, first.options));
            if (!data.finished) {
                this.activeFlows.push(data);
            }
        });
    }
    /**
     *  Run the accept and next function of all active flows
     * @param {MqttPacket} packet
     * @returns {boolean} true if a flow has been found
     */
    continueFlows(packet) {
        var _a, _b, _c, _d;
        let result = false;
        for (const flow of this.activeFlows) {
            if ((_b = (_a = flow.callbacks).accept) === null || _b === void 0 ? void 0 : _b.call(_a, packet.data)) {
                const next = (_d = (_c = flow.callbacks).next) === null || _d === void 0 ? void 0 : _d.call(_c, packet.data);
                if (next) {
                    this.sendData(this.writer.write(next.type, next.options));
                }
                result = true;
            }
        }
        this.clearFinishedFlows();
        return result;
    }
    clearFinishedFlows() {
        this.activeFlows = this.activeFlows.filter(flow => !flow.finished);
    }
    updateKeepAlive(value) {
        value = Math.max(value - 0.5, 1);
        if (this.keepAliveTimer) {
            this.stopExecuting(this.keepAliveTimer);
        }
        this.mqttDebug(`Starting keep-alive-ping {delay: ${value}}`);
        this.keepAliveTimer = this.executePeriodically(value * 1000, () => {
            // assume the defaults are used
            this.startFlow(flow_1.outgoingPingFlow())
                .then(() => this.pingDebug(`PingPong @ ${Date.now()}`))
                .catch(e => {
                this.emitWarning(e);
                this.pingDebug(`PingPong failed. (${e.message})`);
            });
        });
    }
    sendData(data) {
        this.transport.duplex.write(data);
    }
    async handlePacket(packet) {
        var _a, _b;
        this.logReceivedPacket(packet);
        let forceCheckFlows = false;
        switch (packet.type) {
            case mqtt_constants_1.PacketType.ConnAck: {
                const connack = packet;
                if (connack.data.isSuccess) {
                    this.setReady();
                    this.emitConnect(connack.data);
                    if ((_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.keepAlive) {
                        this.updateKeepAlive(this.connectOptions.keepAlive);
                    }
                }
                else {
                    this.setFatal();
                    this.emitError(new errors_1.ConnectError(connack.data.errorName));
                    this.setDisconnected(connack.data.errorName).catch(e => this.emitWarning(e));
                }
                break;
            }
            case mqtt_constants_1.PacketType.Publish: {
                const pub = packet.data;
                this.startFlow(flow_1.incomingPublishFlow({
                    topic: pub.topic,
                    payload: pub.payload,
                    qosLevel: pub.qos,
                    retained: pub.retain,
                    duplicate: pub.duplicate,
                }, (_b = pub.identifier) !== null && _b !== void 0 ? _b : undefined))
                    .then(async (m) => {
                    this.emitMessage(m);
                    await this.messageListener.handleMessage(m);
                })
                    .catch(e => this.emitWarning(e));
                break;
            }
            case mqtt_constants_1.PacketType.Disconnect: {
                // ? this.disconnect();
                this.setDisconnected('disconnect packet received').catch(e => this.emitWarning(e));
                break;
            }
            default:
                forceCheckFlows = true;
        }
        if (!this.continueFlows(packet) && forceCheckFlows) {
            this.emitWarning(new errors_1.UnexpectedPacketError(packet.constructor.name));
        }
    }
    logReceivedPacket(packet) {
        if (packet.type !== mqtt_constants_1.PacketType.PingReq && packet.type !== mqtt_constants_1.PacketType.PingResp)
            this.receiveDebug(`Received ${mqtt_utilities_1.stringifyObject(packet.data)}`);
    }
    reset() {
        super.reset();
        if (this.connecting)
            this.rejectConnectPromise(new Error('Disconnected'));
        if (this.connectTimer)
            clearTimeout(this.connectTimer);
        this.connectTimer = undefined;
        if (this.keepAliveTimer)
            clearInterval(this.keepAliveTimer);
        this.keepAliveTimer = undefined;
        this.activeFlows = [];
        this.transformer.reset();
    }
    setReady() {
        super.setReady();
        this.mqttDebug('Ready!');
        if (this.connectTimer)
            this.stopExecuting(this.connectTimer);
    }
    async setDisconnected(reason) {
        var _a;
        const willReconnect = !this.disconnected && this.ready && !this.connecting && this.autoReconnect;
        if (this.connecting)
            this.rejectConnectPromise(new Error('Disconnected'));
        super.setDisconnected();
        this.emitDisconnect(reason);
        if (!this.transport.duplex.destroyed) {
            await new Promise(resolve => this.transport.duplex.end(resolve));
            if (!this.transport.duplex.writableEnded) {
                this.transport.duplex.destroy(new Error('force destroy'));
            }
        }
        this.stopExecuting(this.keepAliveTimer);
        this.reset();
        if (willReconnect) {
            this.transport.reset();
            this.transformer = this.createTransformer();
            this.transformer.options.debug = (_a = this.transformer.options.debug) !== null && _a !== void 0 ? _a : this.mqttDebug.extend('transformer');
            this.connect().catch(e => this.emitError(e));
        }
    }
}
exports.MqttClient = MqttClient;
//# sourceMappingURL=mqtt.client.js.map