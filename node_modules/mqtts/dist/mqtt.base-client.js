"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MqttBaseClient = exports.StateId = void 0;
const mqtt_utilities_1 = require("./mqtt.utilities");
const EventEmitter = require("eventemitter3");
var StateId;
(function (StateId) {
    StateId[StateId["Fatal"] = -1] = "Fatal";
    StateId[StateId["Created"] = 0] = "Created";
    StateId[StateId["Connecting"] = 1] = "Connecting";
    StateId[StateId["Ready"] = 2] = "Ready";
    StateId[StateId["Disconnected"] = 3] = "Disconnected";
})(StateId = exports.StateId || (exports.StateId = {}));
// TODO: errors
class MqttBaseClient extends EventEmitter {
    constructor(sate = StateId.Created) {
        super();
        this.sate = sate;
        this.emitWarning = (e) => this.emit('warning', e);
        this.emitError = (e) => this.emit('error', e);
        this.emitDisconnect = (reason) => this.emit('disconnect', reason);
        this.emitConnect = (packet) => this.emit('connect', packet);
        this.emitMessage = (message) => this.emit('message', message);
    }
    get current() {
        return this.sate;
    }
    get created() {
        return this.current === StateId.Created;
    }
    get fatal() {
        return this.current === StateId.Fatal;
    }
    get ready() {
        return this.current === StateId.Ready;
    }
    get connecting() {
        return this.current === StateId.Connecting;
    }
    get disconnected() {
        return this.current === StateId.Disconnected;
    }
    next(newState) {
        if (newState > this.current && this.current >= 0) {
            this.sate = newState;
        }
        else {
            throw new Error(`Invalid state requested (current: ${this.current}, requested: ${newState})`);
        }
    }
    expectReady() {
        if (!this.ready) {
            throw new Error(`Expected client to be ready but got ${this.current}`);
        }
    }
    expectCreated() {
        if (!this.created) {
            throw new Error(`Expected client to be created but got ${this.current}`);
        }
    }
    expectConnecting() {
        if (!this.connecting) {
            throw new Error(`Expected client to be connecting but got ${this.current}`);
        }
    }
    reset() {
        if (this.sate === StateId.Created || this.sate === StateId.Disconnected) {
            this.sate = StateId.Created;
        }
        else {
            throw new Error(`Invalid state: Resetting requires the client to be Disconnected or Created (current: ${this.current})`);
        }
    }
    setConnecting() {
        this.next(StateId.Connecting);
    }
    setReady() {
        this.next(StateId.Ready);
    }
    setDisconnected() {
        this.next(StateId.Disconnected);
    }
    setFatal() {
        this.next(StateId.Fatal);
    }
    set connectOptions(options) {
        var _a;
        this._connectOptions = (_a = this._connectOptions) !== null && _a !== void 0 ? _a : options;
    }
    get connectOptions() {
        return this._connectOptions;
    }
    set connectResolver(resolver) {
        var _a;
        this._connectResolver = (_a = this._connectResolver) !== null && _a !== void 0 ? _a : resolver;
    }
    hasConnectOptions() {
        return !!this._connectOptions;
    }
    async resolveConnectOptions() {
        this._connectOptions = {
            ...this._connectOptions,
            ...(this._connectResolver ? await mqtt_utilities_1.resolve(this._connectResolver) : {}),
        };
        return this._connectOptions;
    }
    createConnectPromise() {
        this.expectConnecting();
        if (this._connectPromise) {
            throw new Error('Already created a promise.');
        }
        this._connectPromise = new Promise((resolve, reject) => {
            this._connectResolve = resolve;
            this._connectReject = reject;
        });
        return this._connectPromise;
    }
    resolveConnectPromise() {
        if (!this._connectResolve)
            throw new Error('No resolver found');
        this._connectResolve();
        this._connectPromise = undefined;
        this._connectResolve = undefined;
        this._connectReject = undefined;
    }
    rejectConnectPromise(e) {
        if (!this._connectReject)
            throw new Error('No resolver found');
        this._connectReject(e);
        this._connectPromise = undefined;
        this._connectResolve = undefined;
        this._connectReject = undefined;
    }
}
exports.MqttBaseClient = MqttBaseClient;
//# sourceMappingURL=mqtt.base-client.js.map